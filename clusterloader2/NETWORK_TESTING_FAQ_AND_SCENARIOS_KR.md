# 네트워크 테스트 Q&A와 실전 시나리오 가이드

> 자주 묻는 질문과 실제 인수 테스트 시나리오 설계

---

## 목차

**Part 1: 질문과 답변**
1. [iperf vs Siege vs Fortio: 왜 각각 다른 도구를 쓰나?](#1-iperf-vs-siege-vs-fortio-왜-각각-다른-도구를-쓰나)
2. [TCP/UDP 측정과 HTTP 측정은 무엇이 다른가?](#2-tcpudp-측정과-http-측정은-무엇이-다른가)
3. [Siege vs Fortio: 어느 것이 더 표준인가?](#3-siege-vs-fortio-어느-것이-더-표준인가)
4. [왜 Kubernetes는 Fortio를 안 쓰나?](#4-왜-kubernetes는-fortio를-안-쓰나)
5. [Siege로 HTTP 측정이 충분한가?](#5-siege로-http-측정이-충분한가)

**Part 2: 실전 시나리오 설계**
6. [시나리오 1: Calico vs Cilium CNI 비교 테스트](#6-시나리오-1-calico-vs-cilium-cni-비교-테스트)
7. [시나리오 2: Istio Service Mesh 인수 테스트](#7-시나리오-2-istio-service-mesh-인수-테스트)
8. [시나리오 3: 트래픽 한계점 찾기](#8-시나리오-3-트래픽-한계점-찾기)
9. [시나리오 4: 메모리 사용량과 트래픽 관계](#9-시나리오-4-메모리-사용량과-트래픽-관계)
10. [시나리오 5: 지연 발생 시점 찾기](#10-시나리오-5-지연-발생-시점-찾기)

**Part 3: 인수 테스트 전략**
11. [이것이 클러스터 인수 테스트에 적합한가?](#11-이것이-클러스터-인수-테스트에-적합한가)
12. [인수 테스트 체크리스트 템플릿](#12-인수-테스트-체크리스트-템플릿)

---

# Part 1: 질문과 답변

## 1. iperf vs Siege vs Fortio: 왜 각각 다른 도구를 쓰나?

### 핵심 답변

**iperf로는 HTTP를 측정할 수 없고, Siege/Fortio로는 TCP/UDP 원시 성능을 측정할 수 없습니다.**

이들은 **완전히 다른 계층**을 테스트하는 도구입니다.

### 비유로 이해하기

```
┌─────────────────────────────────────────────────────────────────┐
│                   택배 시스템으로 비유하면                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  iperf (TCP/UDP) = 고속도로 성능 테스트                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │   "서울-부산 고속도로에 트럭이 얼마나 빨리 달릴 수 있나?"  │   │
│  │   "한 번에 트럭 몇 대가 동시에 지나갈 수 있나?"           │   │
│  │   "트럭이 중간에 사라지는(손실) 경우가 있나?"             │   │
│  │                                                         │   │
│  │   → 도로 자체의 성능을 측정                              │   │
│  │   → 트럭에 뭘 싣고 있는지는 관심 없음                    │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Siege/Fortio (HTTP) = 택배 서비스 품질 테스트                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │   "물건 주문하면 얼마나 빨리 배송되나?"                   │   │
│  │   "하루에 주문 몇 건까지 처리 가능한가?"                  │   │
│  │   "배송 중 물건이 파손되는 경우가 있나?"                  │   │
│  │                                                         │   │
│  │   → 실제 서비스 품질을 측정                              │   │
│  │   → 내부적으로 고속도로를 사용하지만, 그건 관심 없음     │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 기술적 이유

```
┌─────────────────────────────────────────────────────────────────┐
│                     OSI 7계층 모델                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Layer 7 (Application)  ← HTTP, gRPC       ← Siege, Fortio     │
│  Layer 6 (Presentation)                                         │
│  Layer 5 (Session)                                              │
│  Layer 4 (Transport)    ← TCP, UDP         ← iperf             │
│  Layer 3 (Network)      ← IP                                    │
│  Layer 2 (Data Link)    ← Ethernet                              │
│  Layer 1 (Physical)     ← 케이블, 광섬유                        │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  iperf가 하는 일:                                               │
│  "Layer 4에서 데이터를 최대한 빨리 보내고 받는다"               │
│  → HTTP 헤더? 파싱? 응답 코드? 전혀 모름                        │
│  → 그냥 바이트 덩어리를 보내고 받을 뿐                          │
│                                                                 │
│  Siege/Fortio가 하는 일:                                        │
│  "Layer 7에서 HTTP 요청을 보내고 응답을 받는다"                 │
│  → GET /api/users HTTP/1.1 같은 요청 전송                       │
│  → 200 OK, 500 Error 같은 응답 확인                             │
│  → 응답 시간, 성공률 측정                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 왜 둘 다 필요한가?

```
실제 상황 예시:

문제: "우리 API가 느려요"

1. iperf로 확인 → 네트워크 대역폭 10Gbps, 정상
   "고속도로는 막히지 않았음"

2. Siege로 확인 → HTTP 응답 시간 5초
   "하지만 택배 처리가 느림"

→ 결론: 네트워크 문제가 아니라 애플리케이션 문제
   (DB 쿼리가 느리거나, 코드에 병목이 있거나)


반대 상황:

문제: "우리 API가 느려요"

1. Siege로 확인 → HTTP 응답 시간 5초
   "택배 배송이 느림"

2. iperf로 확인 → 네트워크 대역폭 100Kbps
   "고속도로가 막혀있음!"

→ 결론: 네트워크 인프라 문제
   (CNI 설정 오류, MTU 불일치, 대역폭 제한 등)
```

---

## 2. TCP/UDP 측정과 HTTP 측정은 무엇이 다른가?

### 핵심 차이

| 구분 | TCP/UDP (iperf) | HTTP (Siege/Fortio) |
|------|-----------------|---------------------|
| **측정 대상** | 네트워크 파이프 자체 | 애플리케이션 서비스 |
| **서버 필요** | iperf 서버만 필요 | 실제 웹 서버 필요 |
| **데이터 내용** | 의미 없는 바이트 | HTTP 요청/응답 |
| **성공 기준** | 데이터 도착 여부 | HTTP 200 응답 여부 |
| **측정 항목** | 대역폭, 지터, 손실 | 응답시간, 처리량, 에러율 |

### 실제 동작 비교

```
┌─────────────────────────────────────────────────────────────────┐
│                  TCP 측정 (iperf)                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Client                              Server                     │
│  ┌─────────────┐                    ┌─────────────┐            │
│  │ iperf -c    │                    │ iperf -s    │            │
│  │             │                    │             │            │
│  │ 보내는 것:   │                    │ 받는 것:    │            │
│  │ ██████████  │───────────────────►│ ██████████  │            │
│  │ ██████████  │  (의미없는 바이트)  │ ██████████  │            │
│  │ ██████████  │                    │ ██████████  │            │
│  └─────────────┘                    └─────────────┘            │
│                                                                 │
│  측정: "10초 동안 500MB 전송 = 50MB/s = 400Mbps"                │
│                                                                 │
│  서버가 하는 일: 그냥 받기만 함 (처리 로직 없음)                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  HTTP 측정 (Siege)                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Client                              Server                     │
│  ┌─────────────┐                    ┌─────────────┐            │
│  │ siege       │                    │ nginx/app   │            │
│  │             │                    │             │            │
│  │ 보내는 것:   │                    │ 받는 것:    │            │
│  │ GET /test   │───────────────────►│ 요청 파싱   │            │
│  │ HTTP/1.1    │                    │ 로직 실행   │            │
│  │ Host: ...   │                    │ DB 조회(?)  │            │
│  │             │◄───────────────────│ 응답 생성   │            │
│  │ 받는 것:    │                    │             │            │
│  │ HTTP 200 OK │                    │ {"ok":true} │            │
│  └─────────────┘                    └─────────────┘            │
│                                                                 │
│  측정: "1000개 요청, 평균 응답시간 50ms, 성공률 99.9%"          │
│                                                                 │
│  서버가 하는 일: 요청 파싱 → 처리 → 응답 생성 (실제 작업)       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### CNI 테스트에서 왜 iperf가 필요한가?

```
Calico/Cilium 같은 CNI가 하는 일:

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Pod A (10.244.1.5)              Pod B (10.244.2.10)            │
│  ┌─────────────┐                ┌─────────────┐                │
│  │   App       │                │   App       │                │
│  │   ↓         │                │   ↑         │                │
│  │  TCP/UDP    │                │  TCP/UDP    │                │
│  │   ↓         │                │   ↑         │                │
│  │  CNI 처리   │                │  CNI 처리   │                │
│  │  (Calico/   │                │  (Calico/   │                │
│  │   Cilium)   │                │   Cilium)   │                │
│  └─────────────┘                └─────────────┘                │
│        │                              ↑                        │
│        │  VXLAN/GENEVE 캡슐화         │                        │
│        └──────────────────────────────┘                        │
│                    물리 네트워크                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

CNI의 성능을 측정하려면:
- HTTP 레벨이 아니라 TCP/UDP 레벨에서 측정해야 함
- HTTP는 애플리케이션 오버헤드가 섞여서 CNI 순수 성능을 알 수 없음
- iperf는 CNI가 처리하는 "순수한 패킷 전달 성능"을 측정
```

---

## 3. Siege vs Fortio: 어느 것이 더 표준인가?

### 결론부터

**"표준"이라는 건 없습니다.** 둘 다 각자의 영역에서 널리 사용됩니다.

| 도구 | 주요 사용처 | 개발/후원 |
|------|------------|-----------|
| **Siege** | 전통적인 웹 서버 테스트 | 1999년부터 개발, 독립 프로젝트 |
| **Fortio** | 마이크로서비스/Service Mesh | 2017년 Istio 프로젝트에서 시작 |

### 각 도구의 강점

```
┌─────────────────────────────────────────────────────────────────┐
│                        Siege의 강점                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 단순함                                                      │
│     siege http://example.com -c10 -t30s                        │
│     → 동시 10명, 30초 테스트. 끝.                               │
│                                                                 │
│  2. 가벼움                                                      │
│     → 바이너리 크기 작음, 의존성 적음                           │
│                                                                 │
│  3. URL 파일 지원                                               │
│     → 여러 URL을 파일로 지정해서 테스트 가능                    │
│                                                                 │
│  4. 오랜 역사                                                   │
│     → 20년 이상 사용, 안정적                                    │
│                                                                 │
│  적합한 상황:                                                   │
│  - 단순한 웹 서버 부하 테스트                                   │
│  - 빠른 성능 확인                                               │
│  - 리소스가 제한된 환경                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                       Fortio의 강점                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. QPS 정밀 제어                                               │
│     fortio load -qps 100 http://example.com                    │
│     → "정확히 초당 100개 요청"을 보장                           │
│     → Siege는 "최대한 빨리"만 가능                              │
│                                                                 │
│  2. 상세한 Percentile                                           │
│     → P50, P75, P90, P99, P99.9 등 세밀한 분포                  │
│     → Siege는 평균, 최대, 최소만 제공                           │
│                                                                 │
│  3. gRPC 지원                                                   │
│     → HTTP/2, gRPC 프로토콜 테스트 가능                         │
│     → Siege는 HTTP/1.1만 지원                                   │
│                                                                 │
│  4. 웹 UI & JSON 출력                                           │
│     → 실시간 그래프, 자동화에 적합한 JSON                       │
│                                                                 │
│  5. Prometheus 연동                                             │
│     → 메트릭 수집 및 모니터링 통합                              │
│                                                                 │
│  적합한 상황:                                                   │
│  - 마이크로서비스 성능 테스트                                   │
│  - SLA 검증 (P99 < 100ms 등)                                    │
│  - Istio/Service Mesh 환경                                      │
│  - gRPC 서비스                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### QPS 제어가 왜 중요한가?

```
시나리오: "우리 서비스가 초당 100개 요청을 처리할 수 있는지 확인"

Siege 방식:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  siege -c10 -t30s http://api.example.com/users                 │
│                                                                 │
│  "동시 10명이 최대한 빨리 요청"                                  │
│                                                                 │
│  결과:                                                          │
│  - 서버가 빠르면: 초당 500개 처리 (너무 많이 보냄)              │
│  - 서버가 느리면: 초당 20개 처리 (너무 적게 보냄)               │
│                                                                 │
│  문제: "초당 100개일 때의 성능"을 정확히 알 수 없음             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Fortio 방식:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  fortio load -qps 100 -t 30s http://api.example.com/users      │
│                                                                 │
│  "정확히 초당 100개 요청"                                       │
│                                                                 │
│  결과:                                                          │
│  - 항상 초당 100개 요청 유지                                    │
│  - 그 상황에서의 응답시간 분포 측정                             │
│                                                                 │
│  이점: "초당 100개일 때 P99 응답시간은 얼마인가?" 정확히 측정   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 왜 Kubernetes는 Fortio를 안 쓰나?

### 정확히 말하면

**Kubernetes 자체는 Fortio도 쓰고, iperf도 씁니다.** 용도가 다를 뿐입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│              Kubernetes 생태계에서의 도구 사용                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Kubernetes Core (네트워크 인프라 테스트)                       │
│  └── ClusterLoader2 → iperf, Siege 사용                        │
│      "CNI, kube-proxy, 노드 간 연결 테스트"                     │
│                                                                 │
│  Istio (Service Mesh 테스트)                                    │
│  └── Fortio 사용 (Istio 팀이 직접 개발)                        │
│      "사이드카 프록시 성능, mTLS 오버헤드 테스트"               │
│                                                                 │
│  사용자 애플리케이션 테스트                                     │
│  └── Fortio, k6, Locust, JMeter 등 자유롭게 선택               │
│      "API 성능, 부하 테스트"                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ClusterLoader2가 Fortio를 안 쓰는 이유

```
ClusterLoader2의 목적:
"Kubernetes 클러스터 자체의 확장성과 성능을 테스트"

테스트 대상:
1. API Server가 몇 개의 Pod를 처리할 수 있나?
2. 스케줄러가 얼마나 빨리 Pod를 배치하나?
3. CNI가 Pod 간 네트워크를 얼마나 잘 연결하나?  ← iperf 사용
4. Service가 생성되면 얼마나 빨리 접근 가능한가?  ← curl 사용

여기서 Fortio가 필요한 부분:
- 없음!
- 테스트하는 건 "애플리케이션"이 아니라 "인프라"
- HTTP API 성능이 아니라 "네트워크 파이프 성능"을 측정

ClusterLoader2의 HTTP 테스트 (Siege):
- "HTTP 응답시간"이 목적이 아님
- "HTTP로 접근 가능한지" 확인이 목적
- 그래서 단순한 Siege로 충분
```

### Fortio를 써야 할 때

```
당신의 상황에서 Fortio가 필요한 경우:

1. Istio 성능 테스트
   - Envoy 사이드카의 오버헤드 측정
   - mTLS 암호화 비용 측정
   → Fortio 권장 (Istio 공식 도구)

2. 마이크로서비스 API 성능 테스트
   - "우리 API가 SLA를 만족하는가?"
   - "P99 응답시간이 100ms 이하인가?"
   → Fortio 권장 (정밀한 QPS 제어)

3. gRPC 서비스 테스트
   - Siege는 gRPC 지원 안 함
   → Fortio 필수
```

---

## 5. Siege로 HTTP 측정이 충분한가?

### 답변: 상황에 따라 다릅니다

```
┌─────────────────────────────────────────────────────────────────┐
│                  Siege가 충분한 경우                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ "서비스가 응답하는가?" 확인                                  │
│  ✓ "대략적인 처리량" 확인                                       │
│  ✓ "기본적인 응답시간" 확인                                     │
│  ✓ 간단한 스모크 테스트                                         │
│  ✓ ClusterLoader2에서의 Service 도달성 테스트                   │
│                                                                 │
│  ClusterLoader2가 Siege를 쓰는 이유:                            │
│  → 복잡한 HTTP 성능이 아니라                                    │
│  → "HTTP로 접근 가능한가?"만 확인하면 됨                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  Siege가 부족한 경우                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✗ 정확한 QPS로 테스트 필요                                     │
│    예: "초당 정확히 1000개 요청에서 성능 측정"                   │
│                                                                 │
│  ✗ 상세한 Percentile 필요                                       │
│    예: "P99.9가 500ms 이하인지 확인"                            │
│                                                                 │
│  ✗ gRPC 테스트 필요                                             │
│    예: "gRPC 서비스 부하 테스트"                                 │
│                                                                 │
│  ✗ SLA 자동 검증 필요                                           │
│    예: "P99 > 100ms면 CI 실패 처리"                             │
│                                                                 │
│  ✗ 시간에 따른 부하 패턴 필요                                   │
│    예: "10분에 걸쳐 0→1000 QPS 점진 증가"                       │
│                                                                 │
│  이런 경우 → Fortio, k6, Locust 등 사용                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# Part 2: 실전 시나리오 설계

## 6. 시나리오 1: Calico vs Cilium CNI 비교 테스트

### 테스트 목적

> "두 CNI 중 어느 것이 우리 환경에 더 적합한가?"

### 테스트 설계

```
┌─────────────────────────────────────────────────────────────────┐
│                 CNI 비교 테스트 구조                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  환경 A: Calico 클러스터          환경 B: Cilium 클러스터       │
│  ┌─────────────────────┐         ┌─────────────────────┐       │
│  │ 동일한 노드 스펙     │         │ 동일한 노드 스펙     │       │
│  │ 동일한 노드 수       │         │ 동일한 노드 수       │       │
│  │ 동일한 Kubernetes    │         │ 동일한 Kubernetes    │       │
│  │                     │         │                     │       │
│  │ CNI: Calico         │         │ CNI: Cilium         │       │
│  └─────────────────────┘         └─────────────────────┘       │
│            │                               │                    │
│            └───────────┬───────────────────┘                    │
│                        │                                        │
│                        ▼                                        │
│              동일한 테스트 실행                                  │
│              결과 비교                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 구체적인 테스트 항목

```yaml
# CNI 비교 테스트 체크리스트

test_cases:

  # 1. 기본 연결성
  - name: "Pod 간 기본 연결"
    tool: iperf (TCP)
    config: 1:1 ratio
    measure: 연결 성공 여부

  # 2. TCP 대역폭
  - name: "TCP 최대 대역폭"
    tool: iperf (TCP)
    config: 1:1 ratio, 30초
    measure: Throughput (kbytes/sec)
    compare: "Calico vs Cilium 대역폭 차이"

  # 3. UDP 성능 (실시간 트래픽 시뮬레이션)
  - name: "UDP 패킷 처리"
    tool: iperf (UDP)
    config: 1:1 ratio, -b 100M
    measure:
      - Jitter (ms)
      - Packet Loss (%)
      - Latency (ms)
    compare: "어느 CNI가 실시간 트래픽에 강한가?"

  # 4. 대규모 동시 통신
  - name: "50:50 동시 통신"
    tool: iperf (TCP)
    config: 50:50 ratio
    measure:
      - Perc05/Perc50 비율 (성능 일관성)
      - 전체 처리량 합계
    compare: "대규모에서 성능 저하가 적은 CNI는?"

  # 5. NetworkPolicy 적용 시 오버헤드
  - name: "NetworkPolicy 오버헤드"
    tool: iperf (TCP)
    config:
      - 정책 없이 측정
      - 정책 100개 적용 후 측정
    measure: 대역폭 감소율
    compare: "정책 적용 시 성능 저하가 적은 CNI는?"
```

### 실제 실행 방법

```bash
# 1. Calico 클러스터에서 테스트
./clusterloader2 \
  --kubeconfig=/path/to/calico-cluster/kubeconfig \
  --testconfig=testing/network/config.yaml \
  --testoverrides=testing/network/tcp_protocol_override.yaml \
  --testoverrides=testing/network/1_1_ratio_override.yaml \
  --report-dir=/results/calico/tcp-1-1

# 2. Cilium 클러스터에서 동일 테스트
./clusterloader2 \
  --kubeconfig=/path/to/cilium-cluster/kubeconfig \
  --testconfig=testing/network/config.yaml \
  --testoverrides=testing/network/tcp_protocol_override.yaml \
  --testoverrides=testing/network/1_1_ratio_override.yaml \
  --report-dir=/results/cilium/tcp-1-1

# 3. 결과 비교
diff /results/calico/tcp-1-1/summary.json /results/cilium/tcp-1-1/summary.json
```

### 예상 결과 해석

```
실제 비교 결과 예시:

┌──────────────────────────────────────────────────────────────────┐
│  테스트 항목          │ Calico        │ Cilium       │ 승자    │
├──────────────────────────────────────────────────────────────────┤
│  TCP 대역폭 (1:1)    │ 4500 KB/s     │ 4800 KB/s    │ Cilium  │
│  TCP 대역폭 (50:50)  │ 4200 KB/s     │ 4600 KB/s    │ Cilium  │
│  UDP Jitter          │ 0.5 ms        │ 0.3 ms       │ Cilium  │
│  UDP Packet Loss     │ 0.01%         │ 0.02%        │ Calico  │
│  Policy 오버헤드     │ -5%           │ -2%          │ Cilium  │
└──────────────────────────────────────────────────────────────────┘

해석:
- 전반적으로 Cilium이 더 나은 성능
- 단, Calico는 패킷 손실이 더 적음
- NetworkPolicy 사용 시 Cilium의 eBPF가 효율적
```

---

## 7. 시나리오 2: Istio Service Mesh 인수 테스트

### 테스트 목적

> "Istio를 설치하면 성능이 얼마나 떨어지는가? 받아들일 수 있는 수준인가?"

### Istio가 추가하는 것

```
┌─────────────────────────────────────────────────────────────────┐
│                    Istio 없을 때                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Pod A                              Pod B                       │
│  ┌─────────────┐                   ┌─────────────┐             │
│  │ App         │────── 직접 ──────►│ App         │             │
│  └─────────────┘      통신        └─────────────┘             │
│                                                                 │
│  지연: ~1ms                                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Istio 있을 때                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Pod A                              Pod B                       │
│  ┌─────────────────┐               ┌─────────────────┐         │
│  │ App             │               │ App             │         │
│  │       ↓         │               │       ↑         │         │
│  │ Envoy Sidecar   │───────────────│ Envoy Sidecar   │         │
│  │ (암호화, 라우팅,│    mTLS      │ (복호화, 라우팅,│         │
│  │  메트릭 수집)   │    통신      │  메트릭 수집)   │         │
│  └─────────────────┘               └─────────────────┘         │
│                                                                 │
│  지연: ~5-10ms (추가 오버헤드)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 테스트 설계

```yaml
# Istio 인수 테스트 항목

test_phases:

  # Phase 1: 베이스라인 (Istio 없이)
  - name: "Baseline (No Istio)"
    steps:
      - CNI 네트워크 성능 측정 (iperf)
      - HTTP 서비스 응답시간 측정 (Fortio)
    purpose: "비교 기준점 확보"

  # Phase 2: Istio 설치 후
  - name: "With Istio (mTLS disabled)"
    steps:
      - 동일 테스트 반복
    purpose: "Envoy 프록시 오버헤드만 측정"

  # Phase 3: mTLS 활성화
  - name: "With Istio (mTLS enabled)"
    steps:
      - 동일 테스트 반복
    purpose: "암호화 오버헤드 추가 측정"

  # Phase 4: 트래픽 정책 추가
  - name: "With Traffic Policies"
    steps:
      - VirtualService, DestinationRule 적용
      - 동일 테스트 반복
    purpose: "라우팅 정책 오버헤드 측정"
```

### Istio 테스트에는 Fortio 권장

```bash
# Fortio로 Istio 성능 테스트 (ClusterLoader2 외부에서)

# 1. Fortio 서버 배포
kubectl apply -f - <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fortio-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fortio-server
  template:
    metadata:
      labels:
        app: fortio-server
    spec:
      containers:
      - name: fortio
        image: fortio/fortio
        ports:
        - containerPort: 8080
EOF

# 2. Fortio 클라이언트에서 테스트
kubectl run fortio-client --rm -it --image=fortio/fortio -- \
  load -qps 100 -t 60s -json /dev/stdout \
  http://fortio-server:8080/echo

# 결과 예시:
# {
#   "RequestedQPS": "100",
#   "ActualQPS": 99.87,
#   "DurationHistogram": {
#     "Percentiles": [
#       {"Percentile": 50, "Value": 0.005},   # P50: 5ms
#       {"Percentile": 90, "Value": 0.012},   # P90: 12ms
#       {"Percentile": 99, "Value": 0.045}    # P99: 45ms
#     ]
#   }
# }
```

### Istio 인수 테스트 통과 기준 예시

```yaml
# Istio 인수 테스트 SLA

acceptance_criteria:

  latency_overhead:
    description: "Istio로 인한 추가 지연"
    baseline: "Istio 없을 때 P50"
    threshold: "< 10ms 추가 지연"
    # 예: Baseline P50=2ms, Istio P50=12ms → 오버헤드 10ms → 경계선

  throughput_degradation:
    description: "처리량 감소율"
    threshold: "< 20% 감소"
    # 예: Baseline 10000 req/s → Istio 8500 req/s → 15% 감소 → 통과

  error_rate:
    description: "에러율"
    threshold: "< 0.1%"

  resource_overhead:
    description: "Envoy 사이드카 리소스"
    cpu_threshold: "< 100m per pod"
    memory_threshold: "< 128Mi per pod"
```

---

## 8. 시나리오 3: 트래픽 한계점 찾기

### 테스트 목적

> "CNI/Istio Pod가 얼마나 많은 트래픽을 버틸 수 있는가?"

### 점진적 부하 증가 테스트

```
┌─────────────────────────────────────────────────────────────────┐
│                  점진적 부하 증가 패턴                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  부하 │                                          ╱──── 한계점  │
│  (QPS)│                                    ╱────╱              │
│       │                              ╱────╱                    │
│   500─┼─────────────────────────────╱────╱                      │
│       │                       ╱────╱                            │
│   400─┼──────────────────────╱────╱                              │
│       │                 ╱────╱                                  │
│   300─┼────────────────╱────╱                                    │
│       │           ╱────╱                                        │
│   200─┼──────────╱────╱                                          │
│       │     ╱────╱                                              │
│   100─┼────╱────╱                                                │
│       │   ╱                                                     │
│     0─┼──┴───────────────────────────────────────────────────   │
│       0    5    10   15   20   25   30   (분)                   │
│                                                                 │
│  각 단계에서 측정:                                               │
│  - 응답시간 (P50, P99)                                          │
│  - 에러율                                                       │
│  - CNI/Istio Pod 리소스 사용량                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 실행 방법 (Fortio 사용)

```bash
#!/bin/bash
# 점진적 부하 테스트 스크립트

TARGET="http://my-service:8080/api"
DURATION="60s"
RESULTS_DIR="/results/load-test"

# QPS를 50씩 증가시키며 테스트
for QPS in 50 100 150 200 250 300 350 400 450 500; do
  echo "Testing at $QPS QPS..."

  # Fortio 부하 테스트
  fortio load -qps $QPS -t $DURATION -json $RESULTS_DIR/qps-$QPS.json $TARGET

  # 동시에 리소스 사용량 수집
  kubectl top pods -l app=calico-node > $RESULTS_DIR/resources-$QPS.txt

  # 잠시 대기 (시스템 안정화)
  sleep 30
done

# 결과 분석
python3 analyze_results.py $RESULTS_DIR
```

### 한계점 식별 방법

```
┌─────────────────────────────────────────────────────────────────┐
│                  한계점 식별 기준                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  응답시간 그래프:                                                │
│                                                                 │
│  P99   │                                          ╱             │
│  (ms)  │                                    ╱────╱              │
│        │                              ╱────╱                    │
│   100──┼─────────────────────────────────────────── SLA 기준    │
│        │                         ↑                              │
│    50──┼────────────────────────┬───────────────                │
│        │                        │                               │
│    10──┼─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┼─ ─ ─ ─ ─ ─ ─                 │
│        │                        │                               │
│      0─┼──┴─────────────────────┴───────────────────            │
│        0   100   200   300   400   500   (QPS)                  │
│                              │                                  │
│                              │                                  │
│                         한계점: 350 QPS                         │
│                         (이후 P99가 급격히 증가)                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

한계점 정의:
1. P99 응답시간이 SLA를 초과하기 시작하는 지점
2. 에러율이 0.1%를 초과하기 시작하는 지점
3. CPU 사용률이 80%를 초과하는 지점
→ 이 중 가장 먼저 발생하는 지점이 "한계점"
```

---

## 9. 시나리오 4: 메모리 사용량과 트래픽 관계

### 테스트 목적

> "트래픽이 증가하면 CNI/Istio Pod의 메모리가 얼마나 증가하는가?"

### 측정 방법

```bash
#!/bin/bash
# 메모리 사용량 모니터링 스크립트

# 1. 기준선 측정 (트래픽 없을 때)
echo "Baseline (no traffic):"
kubectl top pods -n kube-system -l k8s-app=calico-node

# 2. 트래픽 발생 중 지속적 모니터링
while true; do
  TIMESTAMP=$(date +%Y-%m-%d_%H:%M:%S)

  # Calico Node 메모리
  kubectl top pods -n kube-system -l k8s-app=calico-node \
    | awk -v ts="$TIMESTAMP" '{print ts, $1, $3}' >> calico-memory.log

  # Cilium Agent 메모리 (Cilium 사용 시)
  kubectl top pods -n kube-system -l k8s-app=cilium \
    | awk -v ts="$TIMESTAMP" '{print ts, $1, $3}' >> cilium-memory.log

  # Istio Envoy 메모리 (Istio 사용 시)
  kubectl top pods -l istio-proxy \
    | awk -v ts="$TIMESTAMP" '{print ts, $1, $3}' >> envoy-memory.log

  sleep 10
done
```

### Prometheus 쿼리 (더 정확한 방법)

```promql
# Calico 메모리 사용량
container_memory_usage_bytes{
  namespace="kube-system",
  pod=~"calico-node-.*"
}

# Cilium 메모리 사용량
container_memory_usage_bytes{
  namespace="kube-system",
  pod=~"cilium-.*"
}

# Envoy 사이드카 메모리 사용량
container_memory_usage_bytes{
  container="istio-proxy"
}

# 트래픽 양 (Cilium 메트릭)
sum(rate(cilium_forward_bytes_total[5m])) by (direction)
```

### 예상 결과 분석

```
┌─────────────────────────────────────────────────────────────────┐
│              트래픽 vs 메모리 사용량 그래프                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  메모리 │                                                       │
│  (Mi)   │                                                       │
│         │                                          ╱── Calico   │
│   500───┼─────────────────────────────────────────╱             │
│         │                                    ╱───╱              │
│   400───┼───────────────────────────────────╱───╱── Cilium      │
│         │                              ╱───╱                    │
│   300───┼─────────────────────────────╱───╱                      │
│         │                        ╱───╱                          │
│   200───┼───────────────────────╱───╱                            │
│         │                  ╱───╱                                │
│   100───┼─── ─ ─ ─ ─ ─ ─ ╱───╱─ ─ ─ ─ ─ ─ ─ ─ ─ ─ 기준선       │
│         │            ╱───╱                                      │
│       0─┼───────────┴───┴─────────────────────────────          │
│         0    100   200   300   400   500   (Mbps 트래픽)        │
│                                                                 │
│  분석:                                                          │
│  - 기준선: 트래픽 없을 때 ~100Mi                                 │
│  - Cilium이 Calico보다 메모리 효율적                            │
│  - 500Mbps에서 약 400-500Mi 사용                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 10. 시나리오 5: 지연 발생 시점 찾기

### 테스트 목적

> "언제부터 응답 지연이 발생하기 시작하는가?"

### 지연 발생 원인

```
┌─────────────────────────────────────────────────────────────────┐
│                   지연이 발생하는 지점들                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Client Pod → [CNI] → [Network] → [CNI] → Server Pod            │
│      │           │         │         │         │                │
│      │           │         │         │         │                │
│      ▼           ▼         ▼         ▼         ▼                │
│  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐         │
│  │ App   │  │ CNI   │  │ 물리  │  │ CNI   │  │ App   │         │
│  │ 처리  │  │ 처리  │  │ NW    │  │ 처리  │  │ 처리  │         │
│  └───────┘  └───────┘  └───────┘  └───────┘  └───────┘         │
│                                                                 │
│  지연 원인:                                                      │
│  1. CNI 버퍼 오버플로우 (트래픽 > 처리 용량)                     │
│  2. 물리 네트워크 혼잡                                          │
│  3. CPU 부족 (패킷 처리 지연)                                   │
│  4. 메모리 부족 (OOM으로 인한 재시작)                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 측정 방법

```bash
# iperf로 지연 측정 (UDP)
# -e 옵션으로 상세 리포트 (Latency 포함)

# Server
iperf -s -u -e -i 1

# Client (대역폭을 점진적으로 증가)
for BW in 10M 50M 100M 200M 500M 1G; do
  echo "Testing at $BW bandwidth..."
  iperf -c $SERVER_IP -u -b $BW -t 30 -e > latency-$BW.txt
  sleep 10
done
```

### 결과 분석 예시

```
┌─────────────────────────────────────────────────────────────────┐
│                  대역폭 vs 지연시간                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  대역폭     │ Avg Latency │ Jitter   │ Loss    │ 상태          │
│  ───────────┼─────────────┼──────────┼─────────┼───────────    │
│  10 Mbps   │ 0.5 ms      │ 0.1 ms   │ 0.00%   │ ✓ 정상        │
│  50 Mbps   │ 0.6 ms      │ 0.1 ms   │ 0.00%   │ ✓ 정상        │
│  100 Mbps  │ 0.8 ms      │ 0.2 ms   │ 0.00%   │ ✓ 정상        │
│  200 Mbps  │ 1.2 ms      │ 0.3 ms   │ 0.01%   │ ⚠ 주의        │
│  500 Mbps  │ 5.5 ms      │ 2.1 ms   │ 0.5%    │ ✗ 지연 시작   │
│  1 Gbps    │ 25.3 ms     │ 8.5 ms   │ 5.2%    │ ✗ 심각        │
│                                                                 │
│  분석:                                                          │
│  - 200 Mbps까지는 정상 작동                                     │
│  - 500 Mbps에서 지연과 손실 급증                                │
│  - 한계점: 약 300-400 Mbps                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

# Part 3: 인수 테스트 전략

## 11. 이것이 클러스터 인수 테스트에 적합한가?

### 답변: **적합합니다.** 단, 목적을 명확히 해야 합니다.

### 인수 테스트의 종류와 적합한 도구

```
┌─────────────────────────────────────────────────────────────────┐
│                 클러스터 인수 테스트 종류                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 인프라 인수 테스트                                          │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ "클러스터가 제대로 구성되었는가?"                    │    │
│     │                                                      │    │
│     │ 체크 항목:                                           │    │
│     │ ✓ 노드 간 네트워크 연결성                            │    │
│     │ ✓ CNI 정상 동작                                      │    │
│     │ ✓ DNS 작동                                           │    │
│     │ ✓ Service 접근 가능                                  │    │
│     │ ✓ LoadBalancer 프로비저닝                            │    │
│     │                                                      │    │
│     │ 적합한 도구: ClusterLoader2 (iperf + Siege)         │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 성능 기준선 테스트                                          │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ "우리 클러스터의 기본 성능은 어느 정도인가?"         │    │
│     │                                                      │    │
│     │ 체크 항목:                                           │    │
│     │ ✓ 네트워크 대역폭                                    │    │
│     │ ✓ Pod 시작 시간                                      │    │
│     │ ✓ API 서버 응답시간                                  │    │
│     │                                                      │    │
│     │ 적합한 도구: ClusterLoader2                         │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 애플리케이션 성능 테스트                                    │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ "우리 서비스가 SLA를 만족하는가?"                    │    │
│     │                                                      │    │
│     │ 체크 항목:                                           │    │
│     │ ✓ API 응답시간 (P50, P99)                           │    │
│     │ ✓ 처리량 (QPS)                                       │    │
│     │ ✓ 에러율                                             │    │
│     │                                                      │    │
│     │ 적합한 도구: Fortio, k6, Locust                     │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. 컴포넌트 비교 테스트                                        │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ "Calico vs Cilium, 어느 것이 더 나은가?"            │    │
│     │                                                      │    │
│     │ 체크 항목:                                           │    │
│     │ ✓ 처리량 비교                                        │    │
│     │ ✓ 지연시간 비교                                      │    │
│     │ ✓ 리소스 사용량 비교                                 │    │
│     │                                                      │    │
│     │ 적합한 도구: ClusterLoader2 (CNI) + Fortio (Istio) │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 당신의 시나리오에 대한 권장

```
┌─────────────────────────────────────────────────────────────────┐
│               당신의 시나리오별 권장 도구                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시나리오                          권장 도구                     │
│  ─────────────────────────────────────────────────────────      │
│                                                                 │
│  Calico CNI 인수 테스트           ClusterLoader2 (iperf)       │
│  └── TCP/UDP 대역폭, 지터, 손실                                 │
│                                                                 │
│  Cilium CNI 인수 테스트           ClusterLoader2 (iperf)       │
│  └── 동일 테스트로 비교 가능                                    │
│                                                                 │
│  Calico vs Cilium 비교            ClusterLoader2               │
│  └── 동일 환경에서 동일 테스트 실행 후 결과 비교                │
│                                                                 │
│  Istio 인수 테스트                Fortio ★                     │
│  └── HTTP/gRPC 응답시간, QPS 제어 필요                         │
│  └── ClusterLoader2는 Istio 테스트에 최적화되지 않음            │
│                                                                 │
│  트래픽 한계점 찾기               Fortio (HTTP) + iperf (NW)   │
│  └── 점진적 QPS 증가 → Fortio                                  │
│  └── 네트워크 대역폭 한계 → iperf                              │
│                                                                 │
│  메모리 vs 트래픽 관계            Prometheus + Grafana         │
│  └── 모니터링 도구로 리소스 추적                                │
│  └── 트래픽 생성은 iperf 또는 Fortio                           │
│                                                                 │
│  지연 발생 시점                   iperf (UDP -e 옵션)          │
│  └── 상세 Latency 통계 제공                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 12. 인수 테스트 체크리스트 템플릿

### 신규 클러스터 인수 테스트 체크리스트

```yaml
# 클러스터 인수 테스트 체크리스트
# 신규 클러스터 또는 컴포넌트 업그레이드 시 사용

cluster_acceptance_test:

  metadata:
    cluster_name: "production-cluster-01"
    test_date: "2024-01-15"
    tester: "DevOps Team"
    components:
      kubernetes: "1.28.5"
      cni: "Cilium 1.14"
      service_mesh: "Istio 1.20"

  # ═══════════════════════════════════════════════════════════════
  # Phase 1: 기본 연결성 테스트 (필수)
  # ═══════════════════════════════════════════════════════════════
  phase1_connectivity:

    - test: "노드 간 Ping"
      command: "kubectl run test --image=busybox --rm -it -- ping -c 3 <other-node-ip>"
      expected: "0% packet loss"
      result: [ ] PASS  [ ] FAIL

    - test: "Pod 간 TCP 연결"
      tool: "ClusterLoader2 (iperf TCP 1:1)"
      expected: "연결 성공, Throughput > 0"
      result: [ ] PASS  [ ] FAIL

    - test: "Service DNS 해석"
      command: "kubectl run test --image=busybox --rm -it -- nslookup kubernetes.default"
      expected: "IP 주소 반환"
      result: [ ] PASS  [ ] FAIL

    - test: "ClusterIP Service 접근"
      tool: "ClusterLoader2 (ServiceCreationLatency)"
      expected: "Service reachable"
      result: [ ] PASS  [ ] FAIL

  # ═══════════════════════════════════════════════════════════════
  # Phase 2: 네트워크 성능 기준선 (권장)
  # ═══════════════════════════════════════════════════════════════
  phase2_network_baseline:

    - test: "TCP 대역폭 (1:1)"
      tool: "ClusterLoader2 (iperf TCP 1:1)"
      expected: "> 1000 kbytes/sec"
      actual: "_____ kbytes/sec"
      result: [ ] PASS  [ ] FAIL

    - test: "TCP 대역폭 (50:50)"
      tool: "ClusterLoader2 (iperf TCP 50:50)"
      expected: "Perc05/Perc50 > 0.7"
      actual: "Ratio: _____"
      result: [ ] PASS  [ ] FAIL

    - test: "UDP Jitter"
      tool: "ClusterLoader2 (iperf UDP 1:1)"
      expected: "< 5ms"
      actual: "_____ ms"
      result: [ ] PASS  [ ] FAIL

    - test: "UDP Packet Loss"
      tool: "ClusterLoader2 (iperf UDP 1:1)"
      expected: "< 0.1%"
      actual: "_____%"
      result: [ ] PASS  [ ] FAIL

  # ═══════════════════════════════════════════════════════════════
  # Phase 3: LoadBalancer 테스트 (클라우드 환경)
  # ═══════════════════════════════════════════════════════════════
  phase3_loadbalancer:

    - test: "LB 프로비저닝 시간"
      tool: "ClusterLoader2 (L4LB)"
      expected: "< 120초"
      actual: "_____ 초"
      result: [ ] PASS  [ ] FAIL

    - test: "LB 도달성"
      tool: "ClusterLoader2 (ServiceCreationLatency)"
      expected: "외부 IP로 curl 성공"
      result: [ ] PASS  [ ] FAIL

  # ═══════════════════════════════════════════════════════════════
  # Phase 4: Istio 테스트 (Istio 설치 시)
  # ═══════════════════════════════════════════════════════════════
  phase4_istio:

    - test: "Sidecar Injection"
      command: "kubectl get pods -l istio-proxy -A"
      expected: "모든 대상 Pod에 sidecar 존재"
      result: [ ] PASS  [ ] FAIL

    - test: "mTLS 통신"
      command: "istioctl authn tls-check <pod>"
      expected: "mTLS enabled"
      result: [ ] PASS  [ ] FAIL

    - test: "HTTP 응답시간 오버헤드"
      tool: "Fortio (QPS 100)"
      expected: "P99 < 100ms (또는 baseline + 20ms)"
      actual: "P99: _____ ms"
      result: [ ] PASS  [ ] FAIL

    - test: "Envoy 리소스 사용량"
      command: "kubectl top pods -l istio-proxy"
      expected: "CPU < 100m, Memory < 128Mi"
      actual: "CPU: _____, Memory: _____"
      result: [ ] PASS  [ ] FAIL

  # ═══════════════════════════════════════════════════════════════
  # Phase 5: 스트레스 테스트 (선택)
  # ═══════════════════════════════════════════════════════════════
  phase5_stress:

    - test: "트래픽 한계점"
      tool: "Fortio (점진적 QPS 증가)"
      expected: "한계점 문서화"
      actual: "한계점: _____ QPS"
      notes: "_______________"

    - test: "장시간 부하"
      tool: "Fortio (일정 QPS로 1시간)"
      expected: "에러율 < 0.1%, P99 일정"
      result: [ ] PASS  [ ] FAIL

  # ═══════════════════════════════════════════════════════════════
  # 최종 판정
  # ═══════════════════════════════════════════════════════════════
  final_verdict:
    phase1_pass: [ ] YES  [ ] NO  (필수)
    phase2_pass: [ ] YES  [ ] NO  (권장)
    phase3_pass: [ ] YES  [ ] NO  [ ] N/A
    phase4_pass: [ ] YES  [ ] NO  [ ] N/A
    phase5_pass: [ ] YES  [ ] NO  [ ] N/A

    overall: [ ] ACCEPTED  [ ] REJECTED

    notes: |
      _______________________________________________
      _______________________________________________

    sign_off:
      name: "_________________"
      date: "_________________"
```

### 컴포넌트 업그레이드 인수 테스트 (Istio 업그레이드 예시)

```yaml
# Istio 버전 업그레이드 인수 테스트

upgrade_acceptance_test:

  metadata:
    component: "Istio"
    from_version: "1.19.0"
    to_version: "1.20.0"
    cluster: "production-cluster-01"

  # 업그레이드 전 기준선 측정
  before_upgrade:

    - metric: "P50 응답시간"
      tool: "Fortio -qps 100 -t 60s"
      value: "_____ ms"

    - metric: "P99 응답시간"
      tool: "Fortio -qps 100 -t 60s"
      value: "_____ ms"

    - metric: "에러율"
      tool: "Fortio"
      value: "_____%"

    - metric: "Envoy CPU (avg)"
      tool: "Prometheus"
      value: "_____ m"

    - metric: "Envoy Memory (avg)"
      tool: "Prometheus"
      value: "_____ Mi"

  # 업그레이드 후 측정
  after_upgrade:

    - metric: "P50 응답시간"
      value: "_____ ms"
      change: "_____ ms (____%)"
      acceptable: "< 10% 증가"
      result: [ ] PASS  [ ] FAIL

    - metric: "P99 응답시간"
      value: "_____ ms"
      change: "_____ ms (____%)"
      acceptable: "< 20% 증가"
      result: [ ] PASS  [ ] FAIL

    - metric: "에러율"
      value: "_____%"
      acceptable: "< 0.1%"
      result: [ ] PASS  [ ] FAIL

    - metric: "Envoy CPU (avg)"
      value: "_____ m"
      change: "_____ m (____%)"
      acceptable: "< 20% 증가"
      result: [ ] PASS  [ ] FAIL

    - metric: "Envoy Memory (avg)"
      value: "_____ Mi"
      change: "_____ Mi (____%)"
      acceptable: "< 20% 증가"
      result: [ ] PASS  [ ] FAIL

  # 기능 테스트
  functional_tests:

    - test: "mTLS 정상 작동"
      result: [ ] PASS  [ ] FAIL

    - test: "VirtualService 라우팅"
      result: [ ] PASS  [ ] FAIL

    - test: "DestinationRule 적용"
      result: [ ] PASS  [ ] FAIL

    - test: "Circuit Breaker 작동"
      result: [ ] PASS  [ ] FAIL

  # 롤백 계획
  rollback_plan:
    decision: [ ] PROCEED  [ ] ROLLBACK
    rollback_command: "istioctl upgrade --set revision=1-19-0"
```

---

## 요약: 도구 선택 가이드

```
┌─────────────────────────────────────────────────────────────────┐
│                    최종 도구 선택 가이드                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  "무엇을 테스트하고 싶은가?"                                     │
│                                                                 │
│  ├── CNI 네트워크 성능 (Calico, Cilium, Flannel...)            │
│  │   └── ClusterLoader2 + iperf                                │
│  │                                                              │
│  ├── 노드 간 기본 연결성                                        │
│  │   └── ClusterLoader2 + iperf                                │
│  │                                                              │
│  ├── Service (ClusterIP, NodePort, LB) 테스트                  │
│  │   └── ClusterLoader2 + ServiceCreationLatency               │
│  │                                                              │
│  ├── Istio/Service Mesh 성능                                   │
│  │   └── Fortio ★                                              │
│  │                                                              │
│  ├── 마이크로서비스 API 성능                                    │
│  │   └── Fortio 또는 k6                                        │
│  │                                                              │
│  ├── gRPC 서비스 테스트                                         │
│  │   └── Fortio (필수)                                         │
│  │                                                              │
│  ├── 리소스 모니터링                                            │
│  │   └── Prometheus + Grafana                                  │
│  │                                                              │
│  └── 전체 클러스터 확장성                                       │
│      └── ClusterLoader2                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

*이 문서는 실제 인수 테스트 시나리오를 기반으로 작성되었습니다.*
