# Clusterloader2 전체 시나리오 최종 보고서 (도구 활용 포함)

## 1. 개요

본 문서는 `clusterloader2/testing` 디렉토리의 모든 시나리오 파일에 대해, 각 테스트의 목적(GWT)과 더불어 **주요 사용 도구 및 활용 방식**을 함께 정리한 최종 보고서입니다. 이를 통해 각 테스트의 '무엇을'과 '어떻게'를 종합적으로 이해하는 것을 목표로 합니다.

---

## 2. 시나리오 상세 분석

### `testing/access-tokens`
- **목표**: 서비스 어카운트 토큰 인증 관련 API 서버 성능 스트레스 테스트.
- **`config.yaml`**:
    - **Given**: 다수의 토큰과 서비스 어카운트, 그리고 토큰을 사용할 파드가 정의된 클러스터.
    - **When**: 파드가 마운트된 토큰을 사용하여 API 서버에 대량의 요청을 보냄.
    - **Then**: API 서버의 응답 시간이 SLO를 만족해야 함.
- **주요 사용 도구 및 활용 방식**:
    - **`k8s-access-token-benchmark` 클라이언트**: `deployment.yaml`에 정의된 파드는 이 도구가 포함된 컨테이너 이미지를 사용합니다. 파드 내에서 이 클라이언트는 마운트된 모든 서비스 어카운트 토큰을 사용하여 API 서버에 지속적인 `GET` 요청(자기 파드 정보 조회)을 보내는 방식으로 부하를 발생시킵니다.

### `testing/batch`
- **목표**: 대량의 배치 작업(Job) 실행 시의 클러스터 성능 측정.
- **`config.yaml`**:
    - **Given**: `job.yaml` 템플릿과 함께 생성할 Job의 개수가 설정된 클러스터.
    - **When**: 설정된 수의 Job을 동시에 생성.
    - **Then**: Job 완료 시간(`JobCompletionLatency`)이 측정되고, API 서버 성능이 SLO를 만족해야 함.
- **주요 사용 도구 및 활용 방식**:
    - **Kubernetes `Job`**: 쿠버네티스의 기본 리소스인 `Job`을 직접 사용합니다. `job.yaml`에 정의된 간단한 컨테이너(e.g., `busybox`)를 실행하고 성공적으로 완료시키는 것 자체를 테스트 대상으로 삼아, Job 컨트롤러의 성능을 측정합니다.

### `testing/chaosmonkey`
- **목표**: 의도적인 장애 주입을 통해 클러스터의 회복탄력성 검증.
- **`override.yaml`**:
    - **Given**: 워크로드가 실행 중인 클러스터.
    - **When**: 이 파일을 오버라이드로 적용하여 카오스 테스트를 활성화하고, 노드/파드 장애를 주입.
    - **Then**: 장애 상황에서도 서비스가 안정적으로 유지되고 SLO를 만족해야 함.
- **주요 사용 도구 및 활용 방식**:
    - **`chaos-monkey-node-killer` / `pod-killer`**: 이 시나리오의 핵심 도구입니다. Clusterloader2는 `ENABLE_CHAOSMONKEY` 파라미터가 활성화되면, 이 도구들이 포함된 컨테이너 이미지를 실행합니다. 이 컨테이너는 부여된 권한(GCP API 또는 Kubernetes API)을 사용하여 주기적으로 노드를 종료시키거나 파드를 삭제하는 역할을 수행합니다. `density`나 `load` 같은 다른 테스트와 조합하여 사용됩니다.

### `testing/density`, `testing/load`
- **목표**: 클러스터에 높은 밀도의 파드를 생성하거나 다양한 워크로드로 부하를 주어 전반적인 성능 검증.
- **`config.yaml`**:
    - **Given**: 대량의 파드 또는 다양한 워크로드 모듈이 정의된 테스트 설정.
    - **When**: 대량의 파드를 생성하거나, 여러 모듈을 동시에 실행하여 복합적인 부하를 발생시킴.
    - **Then**: API 응답성, 파드 시작 시간, DNS 응답 시간 등 핵심 지표들이 SLO를 만족해야 함.
- **주요 사용 도구 및 활용 방식**:
    - **다양한 기본 컨테이너 이미지**: `pause`, `busybox`, `nginx` 등 표준 컨테이너 이미지를 사용하여 파드 자체를 생성하고 리소스를 점유하는 방식으로 부하를 줍니다.
    - **`chaos-monkey` (선택적)**: `ENABLE_CHAOSMONKEY` 파라미터를 `true`로 설정하면, 밀도/부하 테스트가 진행되는 도중에 카오스 몽키가 동작하여 장애 상황에서의 성능을 함께 측정할 수 있습니다.

### `testing/network`, `testing/l4lb`, `testing/l4ilb`, `testing/neg`
- **목표**: L4/L7 네트워크 경로 및 로드밸런서의 성능 측정.
- **`config.yaml`**:
    - **Given**: 서버/클라이언트 역할을 할 파드들과 LoadBalancer, Ingress 등의 서비스.
    - **When**: 클라이언트 파드가 서버 파드로 대량의 네트워크 트래픽을 전송.
    - **Then**: 네트워크 대역폭, 지연 시간, 처리량, 장애 복구 시간 등이 SLO를 만족해야 함.
- **주요 사용 도구 및 활용 방식**:
    - **`netperf` / `iperf3`**: `testing/network`와 같은 시나리오의 컨테이너 이미지(`k8s.gcr.io/perf-tests/network/netperf-latest` 등)에 포함되어, 파드 간의 순수 네트워크 대역폭(Throughput), 지연 시간(Latency), PPS(Packets Per Second) 등을 측정하는 데 사용됩니다.
    - **`hornet`**: `testing/l4lb` 등의 시나리오에서 L4 로드밸런서의 성능을 측정하기 위해 사용되는 트래픽 생성기입니다.
    - **`siege` / `wrk2`**: L7/HTTP 성능이 중요한 시나리오에서, 특정 서비스 URL에 HTTP 요청 부하를 발생시켜 응답 시간, 처리량(RPS), 에러율 등을 측정하기 위해 컨테이너 내에서 사용될 수 있습니다.

### `testing/request-benchmark`
- **목표**: API 서버의 특정 엔드포인트에 대한 순수 처리 성능 벤치마크.
- **`config.yaml`**:
    - **Given**: 벤치마크 클라이언트 파드.
    - **When**: 클라이언트가 API 서버의 특정 엔드포인트에 직접 대량의 요청을 보냄.
    - **Then**: 해당 엔드포인트의 QPS, 지연 시간 등 순수 처리 성능이 측정됨.
- **주요 사용 도구 및 활용 방식**:
    - **`request-benchmark` 클라이언트**: 이 테스트를 위해 특별히 제작된 벤치마킹 클라이언트입니다. 컨테이너 이미지에 포함되어 있으며, 외부 라이브러리 없이 직접 Go 언어의 HTTP 클라이언트를 사용하여 지정된 API 엔드포인트에 대한 요청을 생성하고 성능을 측정합니다.

### `testing/list` & `testing/watch-list`
- **목표**: 대량의 오브젝트에 대한 `LIST` / `WATCH` API 성능 측정.
- **`config.yaml`**:
    - **Given**: 대량의 리소스(e.g., Secret, ConfigMap)와 이를 감시하거나 리스트업하는 클라이언트 파드.
    - **When**: 리소스를 변경하거나 `LIST` API를 호출.
    - **Then**: `WATCH` 이벤트 전파 지연 시간 또는 `LIST` API 응답 시간이 SLO를 만족해야 함.
- **주요 사용 도구 및 활용 방식**:
    - **Kubernetes Go `client-go`**: 테스트용으로 제작된 클라이언트 컨테이너 내에서 `client-go` 라이브러리를 사용하여 `LIST`와 `WATCH`를 직접 호출하고, 해당 작업에 걸리는 시간을 측정하여 리포트합니다.

(이 외 다른 시나리오들도 위와 같이 대부분 Kubernetes 기본 리소스나, 테스트 목적에 맞게 `client-go` 등으로 개발된 맞춤형 클라이언트를 컨테이너화하여 사용하는 방식을 따릅니다.)
