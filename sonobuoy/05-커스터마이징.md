# Sonobuoy 커스터마이징

Sonobuoy는 플러그인, 필터링, 고급 옵션을 통해 커스터마이징할 수 있습니다.

## 테스트 필터링

### E2E 테스트 태그 기반 필터링

특정 태그를 가진 테스트만 실행하거나 제외할 수 있습니다.

#### 주요 태그

| 태그 | 설명 |
|------|------|
| `[Conformance]` | 공식 Conformance 테스트 |
| `[Disruptive]` | 파괴적 테스트 (노드 재시작 등) |
| `[Serial]` | 순차 실행이 필요한 테스트 |
| `[Slow]` | 실행 시간이 긴 테스트 |
| `[Feature:XXX]` | 특정 기능 관련 테스트 |
| `[NodeConformance]` | 노드 레벨 Conformance 테스트 |
| `[LinuxOnly]` | Linux 전용 테스트 |

#### 사용 예시

```bash
# Conformance 테스트만 실행
sonobuoy run --mode non-disruptive-conformance \
  --e2e-focus="\[Conformance\]" \
  --wait

# Slow 테스트 제외
sonobuoy run --mode non-disruptive-conformance \
  --e2e-skip="\[Slow\]" \
  --wait

# 여러 조건 조합
sonobuoy run --mode non-disruptive-conformance \
  --e2e-focus="\[Conformance\]" \
  --e2e-skip="\[Slow\]|\[Disruptive\]" \
  --wait
```

### 정규식 필터링

테스트 이름 기반으로도 필터링 가능합니다:

```bash
# 특정 테스트 이름 패턴만 실행
sonobuoy run --mode non-disruptive-conformance \
  --e2e-focus="should.*Service" \
  --wait
```

## 고급 옵션

### 네임스페이스 설정

```bash
# 기본 네임스페이스는 "sonobuoy"
sonobuoy run --mode non-disruptive-conformance \
  --sonobuoy-namespace my-sonobuoy \
  --wait
```

### 이미지 레지스트리 설정

```bash
# 사설 레지스트리 사용
sonobuoy run --mode non-disruptive-conformance \
  --e2e-repo-config my-repo-config.yaml \
  --wait
```

### 리소스 제한 설정

```bash
# Aggregator Pod 리소스 제한
sonobuoy run --mode non-disruptive-conformance \
  --aggregator-limits-cpu 2 \
  --aggregator-limits-memory 4Gi \
  --wait
```

### 병렬 실행 설정

```bash
# 테스트 병렬 실행 수 조정
sonobuoy run --mode non-disruptive-conformance \
  --e2e-parallel 8 \
  --wait
```

## 커스텀 플러그인

### 플러그인 구조

Sonobuoy는 플러그인 기반 아키텍처로, 커스텀 플러그인을 추가할 수 있습니다.

#### 플러그인 타입

| 타입 | 설명 | 사용 사례 |
|------|------|----------|
| **Job Plugin** | 단일 Job으로 실행 | 보안 스캔, 구성 검사 |
| **DaemonSet Plugin** | 각 노드에서 실행 | 노드별 로그 수집, 노드 설정 검사 |

### 플러그인 정의 파일 예시

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-custom-plugin
  namespace: sonobuoy
data:
  plugin.yaml: |
    driver: Job
    plugin-name: my-custom-plugin
    result-format: junit
    spec:
      image: my-registry/my-plugin:latest
      args:
        - --config
        - /etc/sonobuoy/config.json
```

### kube-bench 통합 예시

CIS 벤치마크 검사를 Sonobuoy 플러그인으로 통합:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-bench
  namespace: sonobuoy
data:
  plugin.yaml: |
    driver: Job
    plugin-name: kube-bench
    result-format: junit
    spec:
      image: docker.io/aquasec/kube-bench:latest
      args: ["run"]
      env:
        - name: KUBE_BENCH_MASTER
          value: "true"
        - name: KUBE_BENCH_NODE
          value: "true"
```

**사용 방법:**

```bash
# 플러그인 파일 생성 후
sonobuoy gen plugin kube-bench \
  --name kube-bench \
  --image docker.io/aquasec/kube-bench:latest \
  > kube-bench-plugin.yaml

# 플러그인과 함께 실행
sonobuoy run \
  --plugin kube-bench-plugin.yaml \
  --mode non-disruptive-conformance \
  --wait
```

### 커스텀 플러그인 실행

```bash
# 플러그인 파일 지정
sonobuoy run \
  --plugin my-plugin.yaml \
  --mode quick \
  --wait

# 여러 플러그인 동시 실행
sonobuoy run \
  --plugin plugin1.yaml \
  --plugin plugin2.yaml \
  --mode non-disruptive-conformance \
  --wait
```

## 플러그인 개발

### Job Plugin 템플릿

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: job-plugin-template
  namespace: sonobuoy
data:
  plugin.yaml: |
    driver: Job
    plugin-name: job-plugin-template
    result-format: junit  # junit, raw, single-file
    spec:
      image: my-plugin-image:latest
      command: ["/bin/sh"]
      args:
        - -c
        - |
          # 플러그인 로직 실행
          ./run-tests.sh
          # 결과를 /tmp/results에 저장
      volumeMounts:
        - name: results
          mountPath: /tmp/results
      env:
        - name: CLUSTER_INFO
          value: "production"
    volumes:
      - name: results
        emptyDir: {}
```

### DaemonSet Plugin 템플릿

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: daemonset-plugin-template
  namespace: sonobuoy
data:
  plugin.yaml: |
    driver: DaemonSet
    plugin-name: daemonset-plugin-template
    result-format: raw
    spec:
      image: my-daemonset-plugin:latest
      command: ["/bin/sh"]
      args:
        - -c
        - |
          # 각 노드에서 실행될 로직
          collect-node-logs.sh
      volumeMounts:
        - name: host-logs
          mountPath: /host/var/log
          readOnly: true
    volumes:
      - name: host-logs
        hostPath:
          path: /var/log
```

### 결과 형식

| 형식 | 설명 | 출력 위치 |
|------|------|----------|
| `junit` | JUnit XML 형식 | `/tmp/results/junit.xml` |
| `raw` | 원시 파일 | `/tmp/results/` 디렉토리 |
| `single-file` | 단일 파일 | `/tmp/results/results.txt` |

## 실무 활용 예시

### 조직별 정책 검증 플러그인

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: org-policy-check
  namespace: sonobuoy
data:
  plugin.yaml: |
    driver: Job
    plugin-name: org-policy-check
    result-format: junit
    spec:
      image: my-org/policy-checker:latest
      args:
        - --check-resource-quota
        - --check-limit-range
        - --check-network-policy
        - --check-pod-security-policy
      env:
        - name: ORG_POLICY_CONFIG
          valueFrom:
            configMapKeyRef:
              name: org-policy-config
              key: policy.yaml
```

### 네트워크 기능 검증 플러그인

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: network-e2e
  namespace: sonobuoy
data:
  plugin.yaml: |
    driver: Job
    plugin-name: network-e2e
    result-format: junit
    spec:
      image: my-org/network-tester:latest
      args:
        - --test-service-discovery
        - --test-ingress
        - --test-network-policy
        - --test-cni
```

## 플러그인 개발 가이드라인

### 1. 결과 출력

플러그인은 반드시 결과를 `/tmp/results` 디렉토리에 저장해야 합니다:

```bash
# JUnit 형식
/tmp/results/junit.xml

# Raw 형식
/tmp/results/
  ├── test1.log
  ├── test2.log
  └── summary.json
```

### 2. 종료 코드

- `0`: 성공
- `1`: 실패
- 다른 값: 오류

### 3. 로그 출력

플러그인의 표준 출력/오류는 Sonobuoy가 수집합니다:

```bash
# stdout/stderr는 자동 수집
echo "플러그인 실행 중..." >&2
./run-tests.sh
```

## 관련 문서

- [02-구성요소.md](./02-구성요소.md) - 플러그인 아키텍처
- [09-CICD-통합.md](./09-CICD-통합.md) - 커스텀 플러그인을 CI/CD에 통합
